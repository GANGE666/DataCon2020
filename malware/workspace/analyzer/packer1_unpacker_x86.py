#!/usr/bin/env python
# Sample code for X86 of Unicorn. Nguyen Anh Quynh <aquynh@gmail.com>

from __future__ import print_function
from unicorn import *
from unicorn.x86_const import *
import pefile
import hashlib

import traceback

from capstone import *
from capstone.arm64 import *

md = Cs(CS_ARCH_X86, CS_MODE_32)
md.detail = True

TEB_BEGIN, TEB_END = 0x0, 0x1000
STACK_BEGIN, STACK_END = 0x7fff0000, 0x7fff0000 + 2 * 1024 * 1024

def dump_mem_s(uc):
    ad_range = []
    for m in uc.mem_regions():
        ad_range.append([m[0], m[1] + 1])
    try: 
        ad_range.remove([TEB_BEGIN, TEB_END])
        ad_range.remove([STACK_BEGIN, STACK_END])
    except:
        pass
    # print(ad_range)

    mems = b""

    for p in ad_range:
        # with open(f"./dump/{hex(p[0])}-{hex(p[1])}", "wb") as f:
        #     f.write(uc.mem_read(p[0], p[1] - p[0]))
        mems += uc.mem_read(p[0], p[1] - p[0])
    return mems

def dump_mem(uc):
    # merge all sections
    ad_range = []
    for m in uc.mem_regions():
        # print(f"{hex(m[0])} - {hex(m[1])}")
        ad_range.append([m[0], m[1] + 1])
    # while True:
    #     t = None
    #     t1= None
    #     t2= None
    #     for p in ad_range:
    #         for q in ad_range:
    #             if p[0] == q[1]:
    #                 t = 0
    #                 t1 = p
    #                 t2 = q
    #                 break
    #             if p[1] == q[0]:
    #                 t = 1
    #                 t1 = p
    #                 t2 = q
    #                 break
    #         if t != None:
    #             break
    #     if t != None:
    #         t2[1-t] = t1[t]
    #         ad_range.remove(t1)
    #     else:
    #         break

    ad_range.remove([TEB_BEGIN, TEB_END])
    ad_range.remove([STACK_BEGIN, STACK_END])
    # print(ad_range)

    for p in ad_range:
        # for p in uc.mem_regions():
        with open(f"./dump/{hex(p[0])}-{hex(p[1])}", "wb") as f:
            f.write(uc.mem_read(p[0], p[1] - p[0]))


# callback for tracing instructions
def hook_code(uc, address, size, user_data):
    # print(">>> Tracing instruction at 0x%x, instruction size = 0x%x" %(address, size))
    # print(">>> --- EDI is 0x%x" % uc.reg_read(UC_X86_REG_EDI))
    # print(">>> --- ESI is 0x%x" % uc.reg_read(UC_X86_REG_ESI))
    aaa = uc.mem_read(address, size)
    # if address == 0x4eaaa0:
    #     dump_mem(uc)
    #     exit(0)
    # if aaa == b"a":
    #     print("popa")
    #     # exit(0)
    insts = md.disasm(aaa, address)
    for inst in insts:
        print("0x%x:\t%s\t%s" % (inst.address, inst.mnemonic, inst.op_str))


def hook_code64(uc, address, size, user_data):
    print(">>> Tracing instruction at 0x%x, instruction size = 0x%x" % (address, size))
    rip = uc.reg_read(UC_X86_REG_RIP)
    print(">>> RIP is 0x%x" % rip)


def calc_size(size, aligment):
    if size % aligment == 0:
        section_size = int(((size / aligment))) * aligment
    else:
        section_size = int(((size / aligment)) + 1) * aligment
    return section_size

# callback for tracing invalid memory access (READ or WRITE)
def hook_mem_invalid(uc, access, address, size, value, user_data):
    if access == UC_MEM_WRITE_UNMAPPED:
        print(">>> Missing memory is being WRITE at 0x%x, data size = %u, data value = 0x%x" % (address, size, value))
        # if address == 0x79a000:
        #     uc.hook_add(UC_HOOK_CODE, hook_code)

        # map this memory in with 2MB in size
        uc.mem_map(address, 4096)
        # return True to indicate we want to continue emulation
        return True
    else:
        print(">>> Missing memory is being READ at 0x%x, data size = %u, data value = 0x%x" %(address, size, value))
        addr = calc_size(address, 4096)
        uc.mem_map(addr, 4096)
        # return False to indicate we want to stop emulation
        return True
        # return False


# path = "/Users/gg/Desktop/datacon2020/malware/additional/repair_pe/others/unknow_packer/2d191188f7fd1465664199b90b6ef7df"
# path = "/toshiba/datacon/malware/repair_pe/xxg/scripts/2d191188f7fd1465664199b90b6ef7df"
# path = "/toshiba/datacon/malware/repair_pe/xxg/others/93c9e11dc6d9dd24cfc0e50b6d12f809"

# vmp
# path = "/toshiba/datacon/malware/repair_pe/xxg/others/b44f36a8714221280b3402579f4174fb"





def test(path):
    mu = Uc(UC_ARCH_X86, UC_MODE_32)

    with open(path, "rb") as f:
        data = f.read()

    pe = pefile.PE(path)

    imagebase = pe.OPTIONAL_HEADER.ImageBase
    entrypoint = pe.OPTIONAL_HEADER.AddressOfEntryPoint + imagebase
    aligment = pe.OPTIONAL_HEADER.SectionAlignment

    # map PE header
    mu.mem_map(imagebase, calc_size(len(pe.header), aligment))
    mu.mem_write(imagebase, pe.header)

    # setup TEB
    mu.mem_map(TEB_BEGIN, TEB_END)

    # map sections
    for section in pe.sections:
        va = section.VirtualAddress + imagebase
        section_size = calc_size(section.SizeOfRawData, aligment)

        if section_size == 0:
            print(f"[Ignoring] {str(section.Name)}")
            continue

        print("%x - %x" % (va, va + section_size))
        mu.mem_map(va, section_size)
        mu.mem_write(va, section.get_data())

    # set up esp
    stack_va = STACK_BEGIN
    mu.mem_map(stack_va, STACK_END - STACK_BEGIN)
    mu.reg_write(UC_X86_REG_ESP, STACK_END - 1024)

    endpoint = imagebase

    mu.hook_add(UC_HOOK_CODE, hook_code)
    mu.hook_add(UC_HOOK_MEM_READ_UNMAPPED | UC_HOOK_MEM_WRITE_UNMAPPED, hook_mem_invalid)

    try:
        mu.emu_start(entrypoint, endpoint)
    except Exception as e:
        dump_mem(mu)
        print(">>> RIP is 0x%x" % mu.reg_read(UC_X86_REG_RIP))
        print(">>> RSP is 0x%x" % mu.reg_read(UC_X86_REG_RSP))
        print(">>> RAX is 0x%x" % mu.reg_read(UC_X86_REG_RAX))
        print(">>> RBX is 0x%x" % mu.reg_read(UC_X86_REG_RBX))
        print(">>> RCX is 0x%x" % mu.reg_read(UC_X86_REG_RCX))
        print(">>> RDX is 0x%x" % mu.reg_read(UC_X86_REG_RDX))
        print(">>> RSI is 0x%x" % mu.reg_read(UC_X86_REG_RSI))
        print(">>> RDI is 0x%x" % mu.reg_read(UC_X86_REG_RDI))
        traceback.print_exc()


def emu_unpacker(data):
    try:
        mu = Uc(UC_ARCH_X86, UC_MODE_32)

        # with open(path, "rb") as f:
        #     data = f.read()

        pe = pefile.PE(data=data)

        imagebase = pe.OPTIONAL_HEADER.ImageBase
        entrypoint = pe.OPTIONAL_HEADER.AddressOfEntryPoint + imagebase
        aligment = pe.OPTIONAL_HEADER.SectionAlignment

        # print(f"{imagebase} {calc_size(len(pe.header), aligment)}")

        # map PE header
        mu.mem_map(imagebase, calc_size(len(pe.header), aligment))
        mu.mem_write(imagebase, bytes(pe.header))

        # setup TEB
        mu.mem_map(TEB_BEGIN, TEB_END)

        # map sections
        for section in pe.sections:
            va = section.VirtualAddress + imagebase
            section_size = calc_size(section.SizeOfRawData, aligment)

            if section_size == 0:
                print(f"[Ignoring] {str(section.Name)}")
                continue

            print("%x - %x" % (va, va + section_size))
            mu.mem_map(va, section_size)
            mu.mem_write(va, bytes(section.get_data()))

        # set up esp
        stack_va = STACK_BEGIN
        mu.mem_map(stack_va, STACK_END - STACK_BEGIN)
        mu.reg_write(UC_X86_REG_ESP, STACK_END - 1024)

        endpoint = imagebase
        # endpoint = 0xFFFFFFFF

        # mu.hook_add(UC_HOOK_CODE, hook_code)
        mu.hook_add(UC_HOOK_MEM_READ_UNMAPPED | UC_HOOK_MEM_WRITE_UNMAPPED, hook_mem_invalid)
        
    except Exception as e:
        traceback.print_exc()

    try:
        mu.emu_start(entrypoint, endpoint)
        print("Finish???!")
        return dump_mem_s(mu)
    except Exception as e:
        print("unicorn unpacking: ")
        print(">>> EIP is 0x%x" % mu.reg_read(UC_X86_REG_EIP))
        print(">>> ESP is 0x%x" % mu.reg_read(UC_X86_REG_ESP))
        print(">>> EAX is 0x%x" % mu.reg_read(UC_X86_REG_EAX))
        print(">>> EBX is 0x%x" % mu.reg_read(UC_X86_REG_EBX))
        print(">>> ECX is 0x%x" % mu.reg_read(UC_X86_REG_ECX))
        print(">>> EDX is 0x%x" % mu.reg_read(UC_X86_REG_EDX))
        print(">>> ESI is 0x%x" % mu.reg_read(UC_X86_REG_ESI))
        print(">>> EDI is 0x%x" % mu.reg_read(UC_X86_REG_EDI))
        # traceback.print_exc()
        # print("====================================================")
        # print("Is's OK~")
        # dump_mem(mu)
        return dump_mem_s(mu)


if __name__ == '__main__':
    path = "./tmp/2a5ca8347f0b5377c482692c5fd51850.bak"
    print("=" * 35)
    # test(path)
    with open(path, "rb") as f:
        res = emu_unpacker(f.read())
    print(len(res))
    print("=" * 35)
